

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>data_loading &mdash; NEASQC documentation  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css" />
      <link rel="stylesheet" type="text/css" href="_static/contentui.css" />

  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/contentui.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="encoding_protocols" href="dl.encoding_protocols.html" />
    <link rel="prev" title="QQuantLib.DL" href="dl.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            NEASQC documentation
              <img src="_static/logo-neasqc.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="dl.html">QQuantLib.DL</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">data_loading</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#QQuantLib.DL.data_loading.load_angle"><code class="docutils literal notranslate"><span class="pre">load_angle()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#QQuantLib.DL.data_loading.load_angles"><code class="docutils literal notranslate"><span class="pre">load_angles()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#QQuantLib.DL.data_loading.load_angles_brute_force"><code class="docutils literal notranslate"><span class="pre">load_angles_brute_force()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#QQuantLib.DL.data_loading.load_array"><code class="docutils literal notranslate"><span class="pre">load_array()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#QQuantLib.DL.data_loading.load_pf"><code class="docutils literal notranslate"><span class="pre">load_pf()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#QQuantLib.DL.data_loading.load_probability"><code class="docutils literal notranslate"><span class="pre">load_probability()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#QQuantLib.DL.data_loading.multiplexor_ry"><code class="docutils literal notranslate"><span class="pre">multiplexor_ry()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#QQuantLib.DL.data_loading.step_array"><code class="docutils literal notranslate"><span class="pre">step_array()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#QQuantLib.DL.data_loading.uniform_distribution"><code class="docutils literal notranslate"><span class="pre">uniform_distribution()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="dl.encoding_protocols.html">encoding_protocols</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="aa.html">QQuantLib.AA</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="ae.html">QQuantLib.AE</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pe.html">QQuantLib.PE</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="finance.html">QQuantLib.finance</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="qml4var.html">QQuantLib.qml4var</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="qpu.html">QQuantLib.qpu</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="utils.html">QQuantLib.utils</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NEASQC documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="dl.html">QQuantLib.DL</a></li>
      <li class="breadcrumb-item active">data_loading</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-QQuantLib.DL.data_loading">
<span id="data-loading"></span><h1>data_loading<a class="headerlink" href="#module-QQuantLib.DL.data_loading" title="Link to this heading"></a></h1>
<p>This module contains all the functions for creating quantum circuits that
allow loading input data (as numpy arrays) into the amplitude of a
quantum state.  Two different implementations can be used:</p>
<blockquote>
<div><dl class="simple">
<dt><strong>brute force based</strong></dt><dd><p>Original implementation based on the following paper:
<em>Grover, Lov and Rudolph, Terry. Creating superposition that
correspond to efficiently integrable probability distributions.
arXiv (2002). https://arxiv.org/abs/quant-ph/0208112</em></p>
</dd>
<dt><strong>multiplexors based</strong></dt><dd><p>The mandatory controlled rotations by state are implementd using
(a non-recursive version of) the quantum Multiplexors proposed in:
<em>V.V. Shende, S.S. Bullock, and I.L. Markov. Synthesis of quantum-logic
circuits. IEEE Transactions on Computer-Aided Design of Integrated
Circuits and Systems, 25(6):1000ÔÇô1010, Jun 2006
arXiv:quant-ph/0406176v5</em></p>
</dd>
</dl>
</div></blockquote>
<p>Authors: Alberto Pedro Manzano Herrero &amp; Gonzalo Ferro</p>
<dl class="py function">
<dt class="sig sig-object py" id="QQuantLib.DL.data_loading.load_angle">
<span class="sig-prename descclassname"><span class="pre">QQuantLib.DL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QQuantLib.DL.data_loading.load_angle" title="Link to this definition"></a></dt>
<dd><p>Creates an QLM Abstract Gate that apply a rotation of a given angle
into a auxiliary qubit controlled by a given state of the measurement basis.
Direct QLM multi controlled rotations were used for the implementation.</p>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[|\Psi\rangle = \sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle\]</div>
<div class="math notranslate nohighlight">
\[\mathcal{load\_angle}(\theta, |i\rangle)|\Psi\rangle \
=\sum_{j=0, j\ne i}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle+ \
\alpha_i|i\rangle\otimes\big(\cos(\theta)|0\rangle+\sin(\theta) \
|1\rangle\big)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_qubits</strong> (<em>int</em>) – Number of qubits for the control register. The arity of the gate is number_qubits+1.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – Index of the state that we control.</p></li>
<li><p><strong>angle</strong> (<em>float</em>) – Angle that we load.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QQuantLib.DL.data_loading.load_angles">
<span class="sig-prename descclassname"><span class="pre">QQuantLib.DL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_angles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'multiplexor'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QQuantLib.DL.data_loading.load_angles" title="Link to this definition"></a></dt>
<dd><p>This function serves as an interface for the two different implementations
of multi controlled rotations: load_angles_brute_force and multiplexor_RY.</p>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[|\Psi\rangle = \sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle\]</div>
<div class="math notranslate nohighlight">
\[\mathcal{load\_angles}([\theta_j]_{j=0,1,2...2^n-1})|\Psi\rangle \
=\sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes \
\big(\cos(\theta_j)|0\rangle+\sin(\theta_j)|1\rangle\big)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>angles</strong> (<em>numpy array</em>) – Angles to load in the circuit. The arity of the gate is:
int(np.log2(len(angle)))+1.</p></li>
<li><p><strong>method</strong> (<em>string</em>) – Method used in the loading. Default method.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QQuantLib.DL.data_loading.load_angles_brute_force">
<span class="sig-prename descclassname"><span class="pre">QQuantLib.DL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_angles_brute_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QQuantLib.DL.data_loading.load_angles_brute_force" title="Link to this definition"></a></dt>
<dd><p>Given a list of angles this function creates a QLM routine that applies
rotations of each angle of the list, over an auxiliary qubit, controlled
by the different states of the measurement basis.
Direct QLM multi controlled rotations were used for the implementation.</p>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[|\Psi\rangle = \sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle\]</div>
<div class="math notranslate nohighlight">
\[\mathcal{load\_angles\_brute\_force} \
([\theta_j]_{j=0,1,2...2^n-1}) |\Psi\rangle=\sum_{j=0}^{2^n-1} \
\alpha_j|j\rangle\otimes\big(\cos(\theta_j)|0\rangle+ \
\sin(\theta_j)|1\rangle\big)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>angles</strong> (<em>numpy array</em>) – Angles to load in the circuit. The arity of the gate is:
int(np.log2(len(angle)))+1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QQuantLib.DL.data_loading.load_array">
<span class="sig-prename descclassname"><span class="pre">QQuantLib.DL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function_array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'multiplexor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QQuantLib.DL.data_loading.load_array" title="Link to this definition"></a></dt>
<dd><p>Creates a QLM AbstractGate for loading a normalised array into a quantum
state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function_array</strong> (<em>numpy array</em>) – Numpy array with the normalised array to load. The arity of
of the gate is int(np.log2(len(probability_array)))+1.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <dl class="simple">
<dt>type of loading method used:</dt><dd><p>multiplexor : with quantum Multiplexors
brute_force : using multicontrolled rotations by state</p>
</dd>
</dl>
</p></li>
<li><p><strong>id_name</strong> (<em>str</em>) – name for the Abstract Gate</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>f_gate</strong> – AbstractGate customized for loading a normalised array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>AbstractGate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QQuantLib.DL.data_loading.load_pf">
<span class="sig-prename descclassname"><span class="pre">QQuantLib.DL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_pf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p_gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QQuantLib.DL.data_loading.load_pf" title="Link to this definition"></a></dt>
<dd><p>Create a QLM AbstractGate for applying two given operators consecutively.
The operator to implement is: p_gate*f_gate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p_gate</strong> (<em>QLM AbstractGate</em>) – Customized AbstractGate for loading probability distribution.</p></li>
<li><p><strong>f_gate</strong> (<em>QLM AbstractGate</em>) – Customized AbstractGatel for loading integral of a function f(x)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>pf_gate</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>AbstractGate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QQuantLib.DL.data_loading.load_probability">
<span class="sig-prename descclassname"><span class="pre">QQuantLib.DL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probability_array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'multiplexor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QQuantLib.DL.data_loading.load_probability" title="Link to this definition"></a></dt>
<dd><p>Creates a QLM Abstract gate for loading a given discretized probability
distribution using Quantum Multiplexors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probability_array</strong> (<em>numpy array</em>) – Numpy array with the discretized probability to load. The arity of
of the gate is int(np.log2(len(probability_array))).</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <dl class="simple">
<dt>type of loading method used:</dt><dd><p>multiplexor : with quantum Multiplexors
brute_force : using multicontrolled rotations by state</p>
</dd>
</dl>
</p></li>
<li><p><strong>id_name</strong> (<em>str</em>) – name for the Abstract Gate</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>P_Gate</strong> – Customized Abstract Gate for Loading Probability array using
Quantum Multiplexors</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>AbstractGate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QQuantLib.DL.data_loading.multiplexor_ry">
<span class="sig-prename descclassname"><span class="pre">QQuantLib.DL.data_loading.</span></span><span class="sig-name descname"><span class="pre">multiplexor_ry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ordering</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'sequency'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QQuantLib.DL.data_loading.multiplexor_ry" title="Link to this definition"></a></dt>
<dd><p>Given a list of angles this functions creates a QLM routine that applies
rotations of each angle of the list, over an auxiliary qubit, controlled
by the different states of the measurement basis.
The multi-controlled rotations were implemented using Quantum Multiplexors.</p>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[|\Psi\rangle = \sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle\]</div>
<div class="math notranslate nohighlight">
\[\mathcal{multiplexor\_RY} \
([\theta_j]_{j=0,1,2...2^n-1})|\Psi\rangle = \sum_{j=0}^{2^n-1} \
\alpha_j|j\rangle\otimes\big(\cos(\theta_j)|0\rangle+\sin(\theta_j)|1\rangle\big)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>angles</strong> (<em>numpy array</em>) – <dl class="simple">
<dt>Angles to load in the circuit. The arity of the gate is:</dt><dd><p>int(np.log2(len(angle)))+1.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QQuantLib.DL.data_loading.step_array">
<span class="sig-prename descclassname"><span class="pre">QQuantLib.DL.data_loading.</span></span><span class="sig-name descname"><span class="pre">step_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QQuantLib.DL.data_loading.step_array" title="Link to this definition"></a></dt>
<dd><p>Creates are routine which loads an array of size “size”.
This array has ones up to but not included
the index position. The rest of the values are zero.
This is why it is called step_array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<em>int</em>) – position where the step is produced</p></li>
<li><p><strong>size</strong> (<em>int</em>) – size of the array. It has to be a power of 2</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>step_function_gate</strong> – gate which loads the corresponding array. Note that
the arity is: np.log2(size)+1</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Abstract Gate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="QQuantLib.DL.data_loading.uniform_distribution">
<span class="sig-prename descclassname"><span class="pre">QQuantLib.DL.data_loading.</span></span><span class="sig-name descname"><span class="pre">uniform_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#QQuantLib.DL.data_loading.uniform_distribution" title="Link to this definition"></a></dt>
<dd><p>Function to load a uniform distribution in a quantum circuit.</p>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[\mathcal{H}^{\otimes n}|\Psi\rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>number_qubits</strong> (<em>int</em>) – Arity of the output gate.</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="dl.html" class="btn btn-neutral float-left" title="QQuantLib.DL" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="dl.encoding_protocols.html" class="btn btn-neutral float-right" title="encoding_protocols" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright UDC &amp; CESGA 2021-2024.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
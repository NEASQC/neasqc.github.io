

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PL.data_loading &mdash; NEASQC documentation  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css" />
      <link rel="stylesheet" type="text/css" href="_static/contentui.css" />

  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/contentui.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="BTC_02_AE Amplitude Estimation" href="tnbs.BTC_02_AE.html" />
    <link rel="prev" title="BTC_01_PL: Probability Loading" href="tnbs.BTC_01_PL.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            NEASQC documentation
              <img src="_static/logo-neasqc.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="tnbs.html">Benchmark Test Cases</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="tnbs.BTC_01_PL.html">BTC_01_PL: Probability Loading</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_01_PL.html#module-tnbs.BTC_01_PL.my_benchmark_execution">my_benchmark_execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_01_PL.html#module-tnbs.BTC_01_PL.my_benchmark_info">my_benchmark_info</a></li>
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_01_PL.html#module-tnbs.BTC_01_PL.my_benchmark_summary">my_benchmark_summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_01_PL.html#module-tnbs.BTC_01_PL.my_environment_info">my_environment_info</a></li>
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_01_PL.html#module-tnbs.BTC_01_PL.neasqc_benchmark">neasqc_benchmark</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="tnbs.BTC_01_PL.html#subpackage-pl">Subpackage PL</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">PL.data_loading</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-tnbs.BTC_01_PL.PL.load_probabilities">PL.load_probabilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-tnbs.BTC_01_PL.PL.data_extracting">PL.data_extracting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-tnbs.BTC_01_PL.PL.utils">PL.utils</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tnbs.BTC_02_AE.html">BTC_02_AE Amplitude Estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tnbs.BTC_03_QPE.html">BTC_03_QPE: Quantum Phase Estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tnbs.BTC_04_PH.html">BTC_04_PH: Parent Hamiltonian</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NEASQC documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="tnbs.html">Benchmark Test Cases</a></li>
          <li class="breadcrumb-item"><a href="tnbs.BTC_01_PL.html">BTC_01_PL: Probability Loading</a></li>
      <li class="breadcrumb-item active">PL.data_loading</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-tnbs.BTC_01_PL.PL.data_loading">
<span id="pl-data-loading"></span><h1>PL.data_loading<a class="headerlink" href="#module-tnbs.BTC_01_PL.PL.data_loading" title="Link to this heading"></a></h1>
<p>This module contains all the functions in order to load data into the
quantum state.
There are two implementations for the loading of a function:</p>
<blockquote>
<div><ul class="simple">
<li><p>one based on brute force</p></li>
<li><p>one based on multiplexors.</p></li>
</ul>
</div></blockquote>
<p>The implementation of the multiplexors is a non-recursive version of:</p>
<blockquote>
<div><p>V.V. Shende, S.S. Bullock, and I.L. Markov.
Synthesis of quantum-logic circuits.
IEEE Transactions on Computer-Aided Design of Integrated Circuits
and Systems, 25(6):1000–1010, Jun 2006
arXiv:quant-ph/0406176v5</p>
</div></blockquote>
<p>Authors: Alberto Pedro Manzano Herrero &amp; Gonzalo Ferro</p>
<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_loading.get_qlm_probability">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_loading.</span></span><span class="sig-name descname"><span class="pre">get_qlm_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_loading.get_qlm_probability" title="Link to this definition"></a></dt>
<dd><p>Loads an input probability array in a Quantum Circuit, execute it a fixed number of shots
and returns the obtained result</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>np array</em>) – Array with the discretized probability to load into a quantum state</p></li>
<li><p><strong>load_method</strong> (<em>string</em>) – Load method used for creating the Quantum Circuit</p></li>
<li><p><strong>shots</strong> (<em>int</em>) – Number of shots the created Quantum Circuit should be measured.</p></li>
<li><p><strong>qpu</strong> (<em>QPU</em>) – QPU for simulating or executing the Quantum Circuit</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>result</strong> (<em>pandas DataFrame</em>) – Pandas DataFrame with the results of the simulation or execution of the Quantum Circuit</p></li>
<li><p><strong>circuit</strong> (<em>QLM circuit</em>) – QLM Quantum Circuit generated</p></li>
<li><p><strong>quantum_time</strong> (<em>float</em>) – Time used for simulating or executing the Quantum Circuit.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_loading.get_theoric_probability">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_loading.</span></span><span class="sig-name descname"><span class="pre">get_theoric_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_qbits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mean</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_loading.get_theoric_probability" title="Link to this definition"></a></dt>
<dd><p>Create discrete Gaussian probability distribution function (PDF)
:param n_qbits: Number of qubits for interval discretization
:type n_qbits: int
:param mean: Mean of the desired Gaussian distribution
:type mean: float
:param sigma: Standard Deviation of the desired Gaussian distribution.
:type sigma: float</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>x_</strong> (<em>numpy array</em>) – Discretized domain (in 2^n_qbits) for the Gaussian PDF</p></li>
<li><p><strong>data</strong> (<em>numpy array</em>) – Discretized (in 2^n_qbits) Gaussian PDF</p></li>
<li><p><strong>step</strong> (<em>float</em>) – discretizaction step of the domain</p></li>
<li><p><strong>shots</strong> (<em>int</em>) – Number of shots the quantum circuit should be measured</p></li>
<li><p><strong>norma</strong> (<em>scipy function</em>) – scipy.stats.norm function configured for the desired mean and sigma</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_loading.load_angle">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_loading.load_angle" title="Link to this definition"></a></dt>
<dd><p>Creates an QLM Abstract Gate that apply a rotation of a given angle
into a auxiliary qubit controlled by a given state of the measurement basis.
Direct QLM multi controlled rotations were used for the implementation.</p>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[|\Psi\rangle = \sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle\]</div>
<div class="math notranslate nohighlight">
\[\mathcal{load\_angle}(\theta, |i\rangle)|\Psi\rangle \
=\sum_{j=0, j\ne i}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle+ \
\alpha_i|i\rangle\otimes\big(\cos(\theta)|0\rangle+\sin(\theta) \
|1\rangle\big)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_qubits</strong> (<em>int</em>) – Number of qubits for the control register. The arity of the gate is number_qubits+1.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – Index of the state that we control.</p></li>
<li><p><strong>angle</strong> (<em>float</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>routine</strong> – Routine with the quantum circuit that loads the input angle in a quantum state.
Angle that we load.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>qlm QRoutine</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_loading.load_angles">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_angles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'multiplexor'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_loading.load_angles" title="Link to this definition"></a></dt>
<dd><p>This function serves as an interface for the two different implementations
of multi controlled rotations: load_angles_brute_force and multiplexor_RY.</p>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[|\Psi\rangle = \sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle\]</div>
<div class="math notranslate nohighlight">
\[\mathcal{load\_angles}([\theta_j]_{j=0,1,2...2^n-1})|\Psi\rangle \
=\sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes \
\big(\cos(\theta_j)|0\rangle+\sin(\theta_j)|1\rangle\big)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>angles</strong> (<em>numpy array</em>) – Angles to load in the circuit. The arity of the gate is:
int(np.log2(len(angle)))+1.</p></li>
<li><p><strong>method</strong> (<em>string</em>) – Method used in the loading. Default method.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>routine</strong> – Routine with the quantum circuit that loads the input angles in a quantum state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>qlm QRoutine</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_loading.load_angles_brute_force">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_angles_brute_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_loading.load_angles_brute_force" title="Link to this definition"></a></dt>
<dd><p>Given a list of angles this function creates a QLM routine that applies
rotations of each angle of the list, over an auxiliary qubit, controlled
by the different states of the measurement basis.
Direct QLM multi controlled rotations were used for the implementation.</p>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[|\Psi\rangle = \sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle\]</div>
<div class="math notranslate nohighlight">
\[\mathcal{load\_angles\_brute\_force} \
([\theta_j]_{j=0,1,2...2^n-1}) |\Psi\rangle=\sum_{j=0}^{2^n-1} \
\alpha_j|j\rangle\otimes\big(\cos(\theta_j)|0\rangle+ \
\sin(\theta_j)|1\rangle\big)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>angles</strong> (<em>numpy array</em>) – Angles to load in the circuit. The arity of the gate is:
int(np.log2(len(angle)))+1.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>routine</strong> – Routine with the quantum circuit that loads the input angles in a quantum state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>qlm QRoutine</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_loading.load_probability">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_loading.</span></span><span class="sig-name descname"><span class="pre">load_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probability_array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'multiplexor'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'1731671646605993038'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_loading.load_probability" title="Link to this definition"></a></dt>
<dd><p>Creates a QLM Abstract gate for loading a given discretized probability
distribution using Quantum Multiplexors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probability_array</strong> (<em>numpy array</em>) – Numpy array with the discretized probability to load. The arity of
of the gate is int(np.log2(len(probability_array))).</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <dl class="simple">
<dt>type of loading method used:</dt><dd><p>multiplexor : with quantum Multiplexors
brute_force : using multicontrolled rotations by state</p>
</dd>
</dl>
</p></li>
<li><p><strong>id_name</strong> (<em>str</em>) – name for the Abstract Gate</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>P_Gate</strong> – Customized Abstract Gate for Loading Probability array using
Quantum Multiplexors</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>AbstractGate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_loading.mask">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_loading.</span></span><span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_loading.mask" title="Link to this definition"></a></dt>
<dd><p>Transforms the state <span class="math notranslate nohighlight">\(|index\rangle\)</span> into the state
<span class="math notranslate nohighlight">\(|11...1\rangle\)</span> of size number qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_qubits</strong> (<em>int</em>)</p></li>
<li><p><strong>index</strong> (<em>int</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mask</strong> – the gate that we have to apply in order to transform
state <span class="math notranslate nohighlight">\(|index\rangle\)</span>. Note that it affects all states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Qlm abstract gate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_loading.multiplexor_ry">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_loading.</span></span><span class="sig-name descname"><span class="pre">multiplexor_ry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ordering</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'sequency'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_loading.multiplexor_ry" title="Link to this definition"></a></dt>
<dd><p>Given a list of angles this functions creates a QLM routine that applies
rotations of each angle of the list, over an auxiliary qubit, controlled
by the different states of the measurement basis.
The multi-controlled rotations were implemented using Quantum Multiplexors.</p>
<p class="rubric">Notes</p>
<div class="math notranslate nohighlight">
\[|\Psi\rangle = \sum_{j=0}^{2^n-1}\alpha_j|j\rangle\otimes|0\rangle\]</div>
<div class="math notranslate nohighlight">
\[\mathcal{multiplexor\_RY} \
([\theta_j]_{j=0,1,2...2^n-1})|\Psi\rangle = \sum_{j=0}^{2^n-1} \
\alpha_j|j\rangle\otimes\big(\cos(\theta_j)|0\rangle+\sin(\theta_j)|1\rangle\big)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>angles</strong> (<em>numpy array</em>) – <dl class="simple">
<dt>Angles to load in the circuit. The arity of the gate is:</dt><dd><p>int(np.log2(len(angle)))+1.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>routine</strong> – Routine with the quantum circuit that loads the input angles in a quantum state.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>qlm QRoutine</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-tnbs.BTC_01_PL.PL.load_probabilities">
<span id="pl-load-probabilities"></span><h1>PL.load_probabilities<a class="headerlink" href="#module-tnbs.BTC_01_PL.PL.load_probabilities" title="Link to this heading"></a></h1>
<p>Mandatory code for softaware implemetation of the Benchmark Test Case
of PL kernel</p>
<dl class="py class">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.load_probabilities.</span></span><span class="sig-name descname"><span class="pre">LoadProbabilityDensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Probability Loading</p>
<dl class="py method">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.exe">
<span class="sig-name descname"><span class="pre">exe</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.exe" title="Link to this definition"></a></dt>
<dd><p>Execution of workflow</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.get_metrics">
<span class="sig-name descname"><span class="pre">get_metrics</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.get_metrics" title="Link to this definition"></a></dt>
<dd><p>Computing Metrics</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.get_quantum_pdf">
<span class="sig-name descname"><span class="pre">get_quantum_pdf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.get_quantum_pdf" title="Link to this definition"></a></dt>
<dd><p>Computing quantum probability density function</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.get_theoric_pdf">
<span class="sig-name descname"><span class="pre">get_theoric_pdf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.get_theoric_pdf" title="Link to this definition"></a></dt>
<dd><p>Computing theoretical probability densitiy function</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.summary">
<span class="sig-name descname"><span class="pre">summary</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.load_probabilities.LoadProbabilityDensity.summary" title="Link to this definition"></a></dt>
<dd><p>Pandas summary</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.load_probabilities.save">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.load_probabilities.</span></span><span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pl_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">folder</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.load_probabilities.save" title="Link to this definition"></a></dt>
<dd><p>Function for saving staff</p>
</dd></dl>

</section>
<section id="module-tnbs.BTC_01_PL.PL.data_extracting">
<span id="pl-data-extracting"></span><h1>PL.data_extracting<a class="headerlink" href="#module-tnbs.BTC_01_PL.PL.data_extracting" title="Link to this heading"></a></h1>
<p>This module contains auxiliary functions for executing QLM programs based
on QLM Routines or QLM gates and for post processing results from QLM
qpu executions</p>
<p>Authors: Alberto Pedro Manzano Herrero &amp; Gonzalo Ferro Costas</p>
<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_extracting.check_list_type">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_extracting.</span></span><span class="sig-name descname"><span class="pre">check_list_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tipo</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_extracting.check_list_type" title="Link to this definition"></a></dt>
<dd><p>Check if a list x_input is of type tipo
:param x_input:
:type x_input: list
:param tipo: it has to be understandable by numpy
:type tipo: data type</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>y_output</strong> – numpy array of type tipo.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_extracting.create_qcircuit">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_extracting.</span></span><span class="sig-name descname"><span class="pre">create_qcircuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prog_q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_extracting.create_qcircuit" title="Link to this definition"></a></dt>
<dd><p>Given a QLM program creates a QLM circuit</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prog_q</strong> (<em>QLM QProgram</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>circuit</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QLM circuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_extracting.create_qjob">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_extracting.</span></span><span class="sig-name descname"><span class="pre">create_qjob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_extracting.create_qjob" title="Link to this definition"></a></dt>
<dd><p>Given a QLM circuit creates a QLM job</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>circuit</strong> (<em>QLM circuit</em>)</p></li>
<li><p><strong>shots</strong> (<em>int</em>) – number of measurmentes</p></li>
<li><p><strong>qubits</strong> (<em>list</em>) – with the qubits to be measured</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>job</strong> – job for submit to QLM QPU</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QLM job</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_extracting.create_qprogram">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_extracting.</span></span><span class="sig-name descname"><span class="pre">create_qprogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantum_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_extracting.create_qprogram" title="Link to this definition"></a></dt>
<dd><p>Creates a Quantum Program from an input qlm gate or routine</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quantum_gate</strong> (<em>QLM gate</em><em> or </em><em>QLM routine</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>q_prog</strong> – Quantum Program from input QLM gate or routine</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QLM Program.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_extracting.get_results">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_extracting.</span></span><span class="sig-name descname"><span class="pre">get_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantum_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linalg_qpu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_extracting.get_results" title="Link to this definition"></a></dt>
<dd><p>Function for testing an input gate. This function creates the
quantum program for an input gate, the correspondent circuit
and job. Execute the job and gets the results</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quantum_object</strong> (<em>QLM Gate</em><em>, </em><em>Routine</em><em> or </em><em>Program</em>)</p></li>
<li><p><strong>linalg_qpu</strong> (<em>QLM solver</em>)</p></li>
<li><p><strong>shots</strong> (<em>int</em>) – number of shots for the generated job.
if 0 True probabilities will be computed</p></li>
<li><p><strong>qubits</strong> (<em>list</em>) – list with the qubits for doing the measurement when simulating
if None measurement over all allocated qubits will be provided</p></li>
<li><p><strong>complete</strong> (<em>bool</em>) – for return the complete basis state. Useful when shots is not 0
and all the posible basis states are necessary.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>pdf</strong> (<em>pandas DataFrame</em>) – DataFrame with the results of the simulation</p></li>
<li><p><strong>circuit</strong> (<em>QLM circuit</em>)</p></li>
<li><p><strong>q_prog</strong> (<em>QLM Program.</em>)</p></li>
<li><p><strong>job</strong> (<em>QLM job</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.data_extracting.proccess_qresults">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.data_extracting.</span></span><span class="sig-name descname"><span class="pre">proccess_qresults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.data_extracting.proccess_qresults" title="Link to this definition"></a></dt>
<dd><p>Post Process a QLM results for creating a pandas DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>result</strong> (<em>QLM results from a QLM qpu.</em>) – returned object from a qpu submit</p></li>
<li><p><strong>qubits</strong> (<em>int</em>) – number of qubits</p></li>
<li><p><strong>complete</strong> (<em>bool</em>) – for return the complete basis state.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-tnbs.BTC_01_PL.PL.utils">
<span id="pl-utils"></span><h1>PL.utils<a class="headerlink" href="#module-tnbs.BTC_01_PL.PL.utils" title="Link to this heading"></a></h1>
<p>This module contains several auxiliary functions needed by other scripts
of the library</p>
<p>Authors: Alberto Pedro Manzano Herrero &amp; Gonzalo Ferro Costas</p>
<p>Fast Walsh-Hadamard Transform is based on mex function written
by Chengbo <a class="reference external" href="mailto:Li&#37;&#52;&#48;Rice">Li<span>&#64;</span>Rice</a> Uni for his TVAL3 algorithm:</p>
<p><a class="reference external" href="https://github.com/dingluo/fwht/blob/master/FWHT.py">https://github.com/dingluo/fwht/blob/master/FWHT.py</a></p>
<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.utils.bitfield">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.utils.</span></span><span class="sig-name descname"><span class="pre">bitfield</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_int</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.utils.bitfield" title="Link to this definition"></a></dt>
<dd><p>Transforms an int n_int to the corresponding bitfield of size size</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_int</strong> (<em>int</em>) – integer from which we want to obtain the bitfield</p></li>
<li><p><strong>size</strong> (<em>int</em>) – size of the bitfield</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>full</strong> – bitfield representation of n_int with size size</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of ints</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.utils.expmod">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.utils.</span></span><span class="sig-name descname"><span class="pre">expmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.utils.expmod" title="Link to this definition"></a></dt>
<dd><p>For a pair of integer numbers, performs the decomposition:</p>
<div class="math notranslate nohighlight">
\[n_input = base^power+remainder\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_input</strong> (<em>int</em>) – number to decompose</p></li>
<li><p><strong>base</strong> (<em>int</em>) – basis</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>power</strong> (<em>int</em>) – power</p></li>
<li><p><strong>remainder</strong> (<em>int</em>) – remainder</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.utils.fwht">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.utils.</span></span><span class="sig-name descname"><span class="pre">fwht</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ordering</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'sequency'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.utils.fwht" title="Link to this definition"></a></dt>
<dd><p>Fast Walsh Hadamard transform of array x_input
Works as a wrapper for the different orderings
of the Walsh-Hadamard transforms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_input</strong> (<em>numpy array</em>)</p></li>
<li><p><strong>ordering</strong> (<em>string</em>) – desired ordering of the transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>y_output</strong> – Fast Walsh Hadamard transform of array x_input
in the corresponding ordering</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.utils.fwht_dyadic">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.utils.</span></span><span class="sig-name descname"><span class="pre">fwht_dyadic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.utils.fwht_dyadic" title="Link to this definition"></a></dt>
<dd><p>Fast Walsh-Hadamard Transform of array x_input in dyadic ordering
The result is not normalised
Based on mex function written by Chengbo <a class="reference external" href="mailto:Li&#37;&#52;&#48;Rice">Li<span>&#64;</span>Rice</a> Uni for his TVAL3
algorithm.
His code is according to the K.G. Beauchamp’s book – Applications
of Walsh and Related Functions.
:param array:
:type array: numpy array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x_output</strong> – Fast Walsh Hadamard transform of array x_input.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.utils.fwht_natural">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.utils.</span></span><span class="sig-name descname"><span class="pre">fwht_natural</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.utils.fwht_natural" title="Link to this definition"></a></dt>
<dd><p>Fast Walsh-Hadamard Transform of array x in natural ordering
The result is not normalised
:param array:
:type array: numpy array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fast_wh_transform</strong> – Fast Walsh Hadamard transform of array x.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.utils.fwht_sequency">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.utils.</span></span><span class="sig-name descname"><span class="pre">fwht_sequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.utils.fwht_sequency" title="Link to this definition"></a></dt>
<dd><p>Fast Walsh-Hadamard Transform of array x_input in sequence ordering
The result is not normalised
Based on mex function written by Chengbo <a class="reference external" href="mailto:Li&#37;&#52;&#48;Rice">Li<span>&#64;</span>Rice</a> Uni for his TVAL3
algorithm.
His code is according to the K.G. Beauchamp’s book – Applications
of Walsh and Related Functions.
:param x_input:
:type x_input: numpy array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x_output</strong> – Fast Walsh Hadamard transform of array x_input.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_01_PL.PL.utils.left_conditional_probability">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_01_PL.PL.utils.</span></span><span class="sig-name descname"><span class="pre">left_conditional_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probability</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_01_PL.PL.utils.left_conditional_probability" title="Link to this definition"></a></dt>
<dd><p>This function calculate f(i) according to the Lov Grover and Terry
Rudolph 2008 papper:
‘Creating superposition that correspond to efficiently integrable
probability distributions’
<a class="reference external" href="http://arXiv.org/abs/quant-ph/0208112v1">http://arXiv.org/abs/quant-ph/0208112v1</a></p>
<p>Given a discretized probability and an initial number of bins
the function splits each initial region in 2 equally regions and
calculates the conditional probabilities for x is located in the
left part of the new regions when x is located in the region that
contains the corresponding left region</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_bins</strong> (<em>int</em>) – Number of initial bins for splitting the input probabilities</p></li>
<li><p><strong>probability</strong> (<em>np.darray.</em>) – Numpy array with the probabilities to be load.
initial_bins &lt;= len(Probability)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>left_cond_prob</strong> – conditional probabilities of the new initial_bins+1 splits</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.darray</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tnbs.BTC_01_PL.html" class="btn btn-neutral float-left" title="BTC_01_PL: Probability Loading" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tnbs.BTC_02_AE.html" class="btn btn-neutral float-right" title="BTC_02_AE Amplitude Estimation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright UDC &amp; CESGA 2021-2024.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
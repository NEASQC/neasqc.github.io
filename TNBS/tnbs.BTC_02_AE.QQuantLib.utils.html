

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>QQuantLib.utils &mdash; NEASQC documentation  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css" />
      <link rel="stylesheet" type="text/css" href="_static/contentui.css" />

  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=5929fcd5"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="_static/contentui.js"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="BTC_03_QPE: Quantum Phase Estimation" href="tnbs.BTC_03_QPE.html" />
    <link rel="prev" title="QQuantLib.finance" href="tnbs.BTC_02_AE.QQuantLib.finance.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            NEASQC documentation
              <img src="_static/logo-neasqc.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="tnbs.html">Benchmark Test Cases</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tnbs.BTC_01_PL.html">BTC_01_PL: Probability Loading</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="tnbs.BTC_02_AE.html">BTC_02_AE Amplitude Estimation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_02_AE.html#module-tnbs.BTC_02_AE.my_benchmark_execution">my_benchmark_execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_02_AE.html#module-tnbs.BTC_02_AE.my_benchmark_info">my_benchmark_info</a></li>
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_02_AE.html#module-tnbs.BTC_02_AE.my_benchmark_summary">my_benchmark_summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_02_AE.html#module-tnbs.BTC_02_AE.my_environment_info">my_environment_info</a></li>
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_02_AE.html#module-tnbs.BTC_02_AE.neasqc_benchmark">neasqc_benchmark</a></li>
<li class="toctree-l3"><a class="reference internal" href="tnbs.BTC_02_AE.html#ae-sine-integral">ae_sine_integral</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="tnbs.BTC_02_AE.html#subpackage-qquantlib">Subpackage QQuantLib</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="tnbs.BTC_02_AE.QQuantLib.html">BTC_02_AE.QQuantLib</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tnbs.BTC_03_QPE.html">BTC_03_QPE: Quantum Phase Estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tnbs.BTC_04_PH.html">BTC_04_PH: Parent Hamiltonian</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NEASQC documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="tnbs.html">Benchmark Test Cases</a></li>
          <li class="breadcrumb-item"><a href="tnbs.BTC_02_AE.html">BTC_02_AE Amplitude Estimation</a></li>
          <li class="breadcrumb-item"><a href="tnbs.BTC_02_AE.QQuantLib.html">BTC_02_AE.QQuantLib</a></li>
      <li class="breadcrumb-item active">QQuantLib.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="qquantlib-utils">
<h1>QQuantLib.utils<a class="headerlink" href="#qquantlib-utils" title="Link to this heading"></a></h1>
<section id="module-tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils">
<span id="qquantlib-utils-benchmark-utils"></span><h2>QQuantLib.utils.benchmark_utils<a class="headerlink" href="#module-tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils" title="Link to this heading"></a></h2>
<p>Utils functions from benchmark purpouses.</p>
<p>Authors: Alberto Pedro Manzano Herrero &amp; Gonzalo Ferro</p>
<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.combination_for_dictionary">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.</span></span><span class="sig-name descname"><span class="pre">combination_for_dictionary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.combination_for_dictionary" title="Link to this definition"></a></dt>
<dd><p>Creates a list of dictionaries with all the posible combination of
the input dictionary.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_dict</strong> (<em>python dictionary</em>) – python dictionary where each key value MUST be a list. For each
value of a list a new dictioanry will be created</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>list_of_dictionaries</strong> – A list with all posible combination of dictionaries from the
input dictionary</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of python dictionaries</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.combination_for_list">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.</span></span><span class="sig-name descname"><span class="pre">combination_for_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.combination_for_list" title="Link to this definition"></a></dt>
<dd><p>For each dictionary of the list the function creates all posible
combinations. All the posible combinations are concatenated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>input_list</strong> (<em>list</em><em> of </em><em>python dictionary</em>) – The values of each key of the each python dictionary MUST BE lists.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>list_of_combinations</strong> – A list with  the concatenation of all posible combinations for
each dictionary of the input_list</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of python dictionaries</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.create_ae_pe_solution">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.</span></span><span class="sig-name descname"><span class="pre">create_ae_pe_solution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ae_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">problem_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.create_ae_pe_solution" title="Link to this definition"></a></dt>
<dd><p>Creates a list of price estimation problems for solving with amplitude
estimation (AE) techniques. Each element will have the complete
information for generating a price estimation problem and the
configuration for solving it using an AE algorithm. This is each element
is a python dictionary that allows define a price estimation problem
and solving it using a properly configure AE algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ae_list</strong> (<em>list</em>) – List with properly configured AE solvers.</p></li>
<li><p><strong>problem_list</strong> (<em>list</em>) – List with different price estimation problems.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>solve_ae_pe_list</strong> – List where each element is a ae_pricep dictionary
The list will have the combination of each posible amplitude
estimation solver with all posible price problem list</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.create_pe_problem">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.</span></span><span class="sig-name descname"><span class="pre">create_pe_problem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">domain_cfg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">payoff_cfg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">density_cfg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.create_pe_problem" title="Link to this definition"></a></dt>
<dd><p>Create a list of price estimation problems. Each element is a python
dictionary with a complete option price estimation problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>domain_cfg</strong> (<em>list</em><em> of </em><em>dictionaries</em>) – Each dictionary has a domain configuration for a price estimation problem.</p></li>
<li><p><strong>payoffs_cfg</strong> (<em>list</em><em> of </em><em>dictionaries</em>) – Each dictionary has an option configuration for a price estimation problem.</p></li>
<li><p><strong>density_cfg</strong> (<em>list</em><em> of </em><em>dictionaries</em>) – Each dictionary has probability density configuration for a price estimation problem.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>pe_problem_list</strong> – list with different price estimation problems.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of dictionaries</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.list_of_dicts_from_jsons">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.</span></span><span class="sig-name descname"><span class="pre">list_of_dicts_from_jsons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ae_json_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.benchmark_utils.list_of_dicts_from_jsons" title="Link to this definition"></a></dt>
<dd><p>Creates a list of dictionaries from inputs jsons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ae_list</strong> (<em>list</em><em> of </em><em>json.</em>) – List with name of json files with a complete configuration of an
amplitude estimation method</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ae_pricep_list</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of python dictionaries</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-tnbs.BTC_02_AE.QQuantLib.utils.data_extracting">
<span id="qquantlib-utils-data-extracting"></span><h2>QQuantLib.utils.data_extracting<a class="headerlink" href="#module-tnbs.BTC_02_AE.QQuantLib.utils.data_extracting" title="Link to this heading"></a></h2>
<p>This module contains auxiliary functions for executing QLM programs based
on QLM Routines or QLM gates and for post processing results from QLM
qpu executions</p>
<p>Authors: Alberto Pedro Manzano Herrero &amp; Gonzalo Ferro Costas</p>
<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.create_qcircuit">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.</span></span><span class="sig-name descname"><span class="pre">create_qcircuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prog_q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.create_qcircuit" title="Link to this definition"></a></dt>
<dd><p>Given a QLM program creates a QLM circuit</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prog_q</strong> (<em>QLM QProgram</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>circuit</strong></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QLM circuit</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.create_qjob">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.</span></span><span class="sig-name descname"><span class="pre">create_qjob</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.create_qjob" title="Link to this definition"></a></dt>
<dd><p>Given a QLM circuit creates a QLM job</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>circuit</strong> (<em>QLM circuit</em>)</p></li>
<li><p><strong>shots</strong> (<em>int</em>) – number of measurmentes</p></li>
<li><p><strong>qubits</strong> (<em>list</em>) – with the qubits to be measured</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>job</strong> – job for submit to QLM QPU</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QLM job</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.create_qprogram">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.</span></span><span class="sig-name descname"><span class="pre">create_qprogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantum_gate</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.create_qprogram" title="Link to this definition"></a></dt>
<dd><p>Creates a Quantum Program from an input qlm gate or routine</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>quantum_gate</strong> (<em>QLM gate</em><em> or </em><em>QLM routine</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>q_prog</strong> – Quantum Program from input QLM gate or routine</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>QLM Program.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.get_results">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.</span></span><span class="sig-name descname"><span class="pre">get_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantum_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linalg_qpu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.get_results" title="Link to this definition"></a></dt>
<dd><p>Function for testing an input gate. This function creates the
quantum program for an input gate, the correspondent circuit
and job. Execute the job and gets the results</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quantum_object</strong> (<em>QLM Gate</em><em>, </em><em>Routine</em><em> or </em><em>Program</em>)</p></li>
<li><p><strong>linalg_qpu</strong> (<em>QLM solver</em>)</p></li>
<li><p><strong>shots</strong> (<em>int</em>) – number of shots for the generated job.
if 0 True probabilities will be computed</p></li>
<li><p><strong>qubits</strong> (<em>list</em>) – list with the qubits for doing the measurement when simulating
if None measurement over all allocated qubits will be provided</p></li>
<li><p><strong>complete</strong> (<em>bool</em>) – for return the complete basis state. Useful when shots is not 0
and all the posible basis states are necessary.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>pdf</strong> (<em>pandas DataFrame</em>) – DataFrame with the results of the simulation</p></li>
<li><p><strong>circuit</strong> (<em>QLM circuit</em>)</p></li>
<li><p><strong>q_prog</strong> (<em>QLM Program.</em>)</p></li>
<li><p><strong>job</strong> (<em>QLM job</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.proccess_qresults">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.</span></span><span class="sig-name descname"><span class="pre">proccess_qresults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">complete</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.data_extracting.proccess_qresults" title="Link to this definition"></a></dt>
<dd><p>Post Process a QLM results for creating a pandas DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>result</strong> (<em>QLM results from a QLM qpu.</em>) – returned object from a qpu submit</p></li>
<li><p><strong>qubits</strong> (<em>int</em>) – number of qubits</p></li>
<li><p><strong>complete</strong> (<em>bool</em>) – for return the complete basis state.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="qquantlib-utils-qlm-solver">
<h2>QQuantLib.utils.qlm_solver<a class="headerlink" href="#qquantlib-utils-qlm-solver" title="Link to this heading"></a></h2>
</section>
<section id="module-tnbs.BTC_02_AE.QQuantLib.utils.utils">
<span id="qquantlib-utils-utils"></span><h2>QQuantLib.utils.utils<a class="headerlink" href="#module-tnbs.BTC_02_AE.QQuantLib.utils.utils" title="Link to this heading"></a></h2>
<p>This module contains several auxiliary functions needed by other scripts
of the library</p>
<p>Authors: Alberto Pedro Manzano Herrero &amp; Gonzalo Ferro Costas</p>
<p>Fast Walsh-Hadamard Transform is based on mex function written
by Chengbo <a class="reference external" href="mailto:Li&#37;&#52;&#48;Rice">Li<span>&#64;</span>Rice</a> Uni for his TVAL3 algorithm:</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/dingluo/fwht/blob/master/FWHT.py">https://github.com/dingluo/fwht/blob/master/FWHT.py</a></p>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.bitfield">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">bitfield</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_int</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.bitfield" title="Link to this definition"></a></dt>
<dd><p>Transforms an int n_int to the corresponding bitfield of size size</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_int</strong> (<em>int</em>) – integer from which we want to obtain the bitfield</p></li>
<li><p><strong>size</strong> (<em>int</em>) – size of the bitfield</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>full</strong> – bitfield representation of n_int with size size</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of ints</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.bitfield_to_int">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">bitfield_to_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lista</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.bitfield_to_int" title="Link to this definition"></a></dt>
<dd><p>Transforms the bitfield list to the corresponding int
:param lista: bitfield
:type lista: ist of ints</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>integer</strong> – integer obtained from it’s binary representation.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.check_list_type">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">check_list_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tipo</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.check_list_type" title="Link to this definition"></a></dt>
<dd><p>Check if a list x_input is of type tipo
:param x_input:
:type x_input: list
:param tipo: it has to be understandable by numpy
:type tipo: data type</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>y_output</strong> – numpy array of type tipo.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.expmod">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">expmod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.expmod" title="Link to this definition"></a></dt>
<dd><p>For a pair of integer numbers, performs the decomposition:</p>
<div class="math notranslate nohighlight">
\[n_input = base^power+remainder\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_input</strong> (<em>int</em>) – number to decompose</p></li>
<li><p><strong>base</strong> (<em>int</em>) – basis</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>power</strong> (<em>int</em>) – power</p></li>
<li><p><strong>remainder</strong> (<em>int</em>) – remainder</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.fwht">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">fwht</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ordering</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'sequency'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.fwht" title="Link to this definition"></a></dt>
<dd><p>Fast Walsh Hadamard transform of array x_input
Works as a wrapper for the different orderings
of the Walsh-Hadamard transforms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_input</strong> (<em>numpy array</em>)</p></li>
<li><p><strong>ordering</strong> (<em>string</em>) – desired ordering of the transform</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>y_output</strong> – Fast Walsh Hadamard transform of array x_input
in the corresponding ordering</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.fwht_dyadic">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">fwht_dyadic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.fwht_dyadic" title="Link to this definition"></a></dt>
<dd><p>Fast Walsh-Hadamard Transform of array x_input in dyadic ordering
The result is not normalised
Based on mex function written by Chengbo <a class="reference external" href="mailto:Li&#37;&#52;&#48;Rice">Li<span>&#64;</span>Rice</a> Uni for his TVAL3
algorithm.
His code is according to the K.G. Beauchamp’s book – Applications
of Walsh and Related Functions.
:param array:
:type array: numpy array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x_output</strong> – Fast Walsh Hadamard transform of array x_input.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.fwht_natural">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">fwht_natural</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.fwht_natural" title="Link to this definition"></a></dt>
<dd><p>Fast Walsh-Hadamard Transform of array x in natural ordering
The result is not normalised
:param array:
:type array: numpy array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fast_wh_transform</strong> – Fast Walsh Hadamard transform of array x.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.fwht_sequency">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">fwht_sequency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.fwht_sequency" title="Link to this definition"></a></dt>
<dd><p>Fast Walsh-Hadamard Transform of array x_input in sequence ordering
The result is not normalised
Based on mex function written by Chengbo <a class="reference external" href="mailto:Li&#37;&#52;&#48;Rice">Li<span>&#64;</span>Rice</a> Uni for his TVAL3
algorithm.
His code is according to the K.G. Beauchamp’s book – Applications
of Walsh and Related Functions.
:param x_input:
:type x_input: numpy array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x_output</strong> – Fast Walsh Hadamard transform of array x_input.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.get_histogram">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">get_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">probability</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.get_histogram" title="Link to this definition"></a></dt>
<dd><p>Given a function probability, convert it into a histogram. The
function must be positive, the normalization is automatic. Note
that instead of having an analytical expression, probability could
just create an arbitrary vector of the right dimensions and positive
amplitudes.  This procedure could be used to initialize any quantum
state with real amplitudes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low_limit</strong> (<em>float</em>) – lower limit of the interval</p></li>
<li><p><strong>high_limit</strong> (<em>float</em>) – upper limit of the interval</p></li>
<li><p><strong>probability</strong> (<em>function</em>) – function that we want to convert to a probability mass function
It does not have to be normalized but must be positive
in the interval</p></li>
<li><p><strong>nbin</strong> (<em>int</em>) – number of bins in the interval</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>centers</strong> (<em>np.darray</em>) – numpy array with the centers of the bins of the histogram</p></li>
<li><p><strong>probs</strong> (<em>np.darray</em>) – numpy array with the probability at the centers of the bins
of the histogram</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.left_conditional_probability">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">left_conditional_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_bins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">probability</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.left_conditional_probability" title="Link to this definition"></a></dt>
<dd><p>This function calculate f(i) according to the Lov Grover and Terry
Rudolph 2008 papper:
‘Creating superposition that correspond to efficiently integrable
probability distributions’
<a class="reference external" href="http://arXiv.org/abs/quant-ph/0208112v1">http://arXiv.org/abs/quant-ph/0208112v1</a></p>
<p>Given a discretized probability and an initial number of bins
the function splits each initial region in 2 equally regions and
calculates the conditional probabilities for x is located in the
left part of the new regions when x is located in the region that
contains the corresponding left region</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>initial_bins</strong> (<em>int</em>) – Number of initial bins for splitting the input probabilities</p></li>
<li><p><strong>probability</strong> (<em>np.darray.</em>) – Numpy array with the probabilities to be load.
initial_bins &lt;= len(Probability)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>left_cond_prob</strong> – conditional probabilities of the new initial_bins+1 splits</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.darray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.load_qn_gate">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">load_qn_gate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">qlm_gate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_times</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.load_qn_gate" title="Link to this definition"></a></dt>
<dd><p>Create an AbstractGate by applying an input gate n times</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qlm_gate</strong> (<em>QLM gate</em>) – QLM gate that will be applied n times</p></li>
<li><p><strong>n_times</strong> (<em>int</em>) – number of times the qlm_gate will be applied</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.mask">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">number_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.mask" title="Link to this definition"></a></dt>
<dd><p>Transforms the state <span class="math notranslate nohighlight">\(|index\rangle\)</span> into the state
<span class="math notranslate nohighlight">\(|11...1\rangle\)</span> of size number qubits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>number_qubits</strong> (<em>int</em>)</p></li>
<li><p><strong>index</strong> (<em>int</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mask</strong> – the gate that we have to apply in order to transform
state <span class="math notranslate nohighlight">\(|index\rangle\)</span>. Note that it affects all states.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Qlm abstract gate</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.measure_state_probability">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">measure_state_probability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.measure_state_probability" title="Link to this definition"></a></dt>
<dd><p>From an input result DataFrame gets the probability of target state</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_result</strong> (<em>Pandas DataFrame</em>) – DataFrame with measurement results like obtained in the
get_results function (from QQuantLib.utils.data_extracting)</p></li>
<li><p><strong>target</strong> (<em>list</em>) – python list with the state we want to extract</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>output_probability</strong> – Probability of the desired target state. If the state it is not
found then 0.0 is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.oracle_shots_calculation">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">oracle_shots_calculation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.oracle_shots_calculation" title="Link to this definition"></a></dt>
<dd><p>Function for computing the total number of oracle shots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m_k</strong> (<em>list</em>) – list with integers. Applications of the Grover-like
amplification operator.</p></li>
<li><p><strong>n_k</strong> (<em>list</em>) – list with integers. Number of shots for each value of m_k.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>oracle_shots</strong> – Number of total oracle calls for the input schedule</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.test_bins">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">test_bins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'probability'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.test_bins" title="Link to this definition"></a></dt>
<dd><p>Testing condition for numpy arrays. The length of the array must
be 2^n with n an int.
:param array: Numpy Array whose dimensionality is going to test
:type array: np.ndarray
:param test: String for identification purposes
:type test: str</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>AssertionError</strong> – If lengt of array is not 2^n with n an int.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>nqbits</strong> – Minimum number of qbits mandatory for storing input array in a
quantum state</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="tnbs.BTC_02_AE.QQuantLib.utils.utils.text_is_none">
<span class="sig-prename descclassname"><span class="pre">tnbs.BTC_02_AE.QQuantLib.utils.utils.</span></span><span class="sig-name descname"><span class="pre">text_is_none</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variable_type=&lt;class</span> <span class="pre">'float'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tnbs.BTC_02_AE.QQuantLib.utils.utils.text_is_none" title="Link to this definition"></a></dt>
<dd><p>Raise an exception if variable is None</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tnbs.BTC_02_AE.QQuantLib.finance.html" class="btn btn-neutral float-left" title="QQuantLib.finance" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="tnbs.BTC_03_QPE.html" class="btn btn-neutral float-right" title="BTC_03_QPE: Quantum Phase Estimation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright UDC &amp; CESGA 2021-2022.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>